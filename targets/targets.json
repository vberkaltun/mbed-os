{
    "Target": {
        "core": null,
        "trustzone": false,
        "default_toolchain": "GCC_ARM",
        "supported_toolchains": null,
        "extra_labels": [],
        "supported_form_factors": [],
        "components": [],
        "is_disk_virtual": false,
        "macros": [],
        "device_has": [],
        "features": [],
        "detect_code": [],
        "public": false,
        "c_lib": "std",
        "bootloader_supported": true,
        "static_memory_defines": true,
        "printf_lib": "minimal-printf",
        "supported_c_libs": {
            "gcc_arm": [
                "std",
                "small"
            ]
        },
        "supported_application_profiles": [
            "full"
        ],
        "config": {
            "console-uart": {
                "help": "Target has UART console on pins CONSOLE_TX, CONSOLE_RX. Value is only significant if target has SERIAL device.",
                "value": true
            },
            "console-uart-flow-control": {
                "help": "Console hardware flow control. Options: null, RTS, CTS, RTSCTS.",
                "value": null
            },
            "deep-sleep-latency": {
                "help": "Time in ms required to go to and wake up from deep sleep (max 10)",
                "value": 4
            },
            "boot-stack-size": {
                "help": "Define the boot stack size in bytes. This value must be a multiple of 8",
                "value": "0x200"
            },
            "mpu-rom-end": {
                "help": "Last address of ROM protected by the MPU",
                "value": "0x0fffffff"
            },
            "tickless-from-us-ticker": {
                "help": "Run tickless from the microsecond ticker rather than the low power ticker. Running tickless off of the microsecond ticker improves interrupt latency on targets which use lpticker_delay_ticks",
                "value": false
            },
            "init-us-ticker-at-boot": {
                "help": "Initialize the microsecond ticker at boot rather than on first use, and leave it initialized. This speeds up wait_us in particular.",
                "value": true
            },
            "default-adc-vref": {
                "help": "Default reference voltage for ADC (float)",
                "value": "NAN"
            },
            "internal-flash-uniform-sectors": {
                "help": "Target's internal flash has uniform sector sizes",
                "value": true
            }
        }
    },
    "MCU_STM32": {
        "inherits": [
            "Target"
        ],
        "public": false,
        "extra_labels": [
            "STM"
        ],
        "supported_toolchains": [
            "GCC_ARM"
        ],
        "supported_c_libs": {
            "gcc_arm": [
                "std",
                "small"
            ]
        },
        "supported_application_profiles": [
            "platform",
            "drivers"
        ],
        "macros": [
            "USE_HAL_DRIVER",
            "USE_FULL_LL_DRIVER"
        ],
        "config": {
            "lse_available": {
                "help": "Define if a Low Speed External xtal (LSE) is available on the board (0 = No, 1 = Yes). If Yes, the LSE will be used to clock the RTC, LPUART, ... otherwise the Low Speed Internal clock (LSI) will be used",
                "value": "1"
            },
            "rtc_clock_source": {
                "help": "Define the RTC clock source. USE_RTC_CLK_LSE_OR_LSI, USE_RTC_CLK_LSI, USE_RTC_CLK_HSE. LPTICKER is not available for HSE and should be removed from the target configuration.",
                "value": "USE_RTC_CLK_LSE_OR_LSI"
            },
            "clock_source": {
                "help": "Mask value : USE_PLL_HSE_EXTC (need HW patch) | USE_PLL_HSE_XTAL (need HW patch) | USE_PLL_HSI",
                "value": "USE_PLL_HSE_EXTC|USE_PLL_HSI",
                "macro_name": "CLOCK_SOURCE"
            },
            "lpticker_lptim": {
                "help": "This target supports LPTIM. Set value 1 to use LPTIM for LPTICKER, or 0 to use RTC wakeup timer",
                "value": 0
            },
            "lse_drive_load_level": {
                "help": "HSE drive load level  RCC_LSEDRIVE_LOW | RCC_LSEDRIVE_MEDIUMLOW | RCC_LSEDRIVE_MEDIUMHIGH | RCC_LSEDRIVE_HIGH",
                "value": "RCC_LSEDRIVE_LOW"
            },
            "i2c_timing_value_algo": {
                "help": "If value was set to true I2C timing algorithm is enabled. Enabling may leads to performance issue. Keeping this false and changing system clock will trigger assert.)",
                "value": false
            }
        },
        "device_has": [
            "USTICKER",
            "ANALOGIN",
            "ANALOGOUT",
            "SPI",
            "I2C",
            "I2CSLAVE",
            "I2C_ASYNCH",
            "INTERRUPTIN",
            "SERIAL",
            "STDIO_MESSAGES",
            "FLASH",
            "FLASHIAP",
            "MPU"
        ]
    },
    "NUCLEO_L073RB": {
        "inherits": [
            "MCU_STM32"
        ],
        "core": "Cortex-M0+",
        "extra_labels_add": [
            "STM32L0",
            "STM32L073xB"
        ],
        "macros_add": [
            "STM32L073xx"
        ],
        "supported_form_factors": [
            "ARDUINO_UNO"
        ],
        "device_name": "STM32L073RBTx"
    }
}
